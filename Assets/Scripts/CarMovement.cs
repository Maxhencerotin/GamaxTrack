using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using Unity.VisualScripting;
using UnityEngine.UIElements;
using TMPro.Examples;

public class CarMovement : MonoBehaviour
{
    private const float CAR_MASS = 500.0f;              //in kg
    private const float LINEAR_DRAG = 0.3f;             //so the car gets a maximum speed   (~0.3 seems ok with 500kg --> max speed = 120km/h)
    private const float ANGULAR_DRAG = 3.0f;            //high (3.0) since we don't use physics for turning, it is usefull to make the rotation disapear fast after a collision for example

    private const float NORMAL_CAR_POWER = 5000f;       //in Newton  
    private const float NORMAL_STEERING_POWER = 45f;    //no unity because turning here does not rely on physics
    private const float NORMAL_WHEEL_GRIP = 0.8f;       //between 0 (like rails (0.0 not good for collisions)) and 1 (like space) (0.8 good)
    //private const float SLIDING_CAR_POWER = 0.0f;     //in Newton  
    private const float SLIDING_STEERING_POWER = 20f;   //no unity because turning here does not rely on physics
    private const float SLIDING_WHEEL_GRIP = 0.99f;     //between 0 (like rails) and 1 (like space) (0.8 good) (0.0 and 1.0 not good !! )
    //private const float MAX_SPEED = 100f;             //not necessary with the linear drag
    private const float BACKWARD_MAX_SPEED = 4.0f;      //in m/s
    private const float BACKWARD_STEARING_RATIO = 0.5f; //multiply the STEARING_POWER
    private const float GROUND_GRIPPINESS = 500f;       //in Newton (force applied on the car when it is sliding)

    private const float MINIMUM_SLIDING_SPEED = 8.0f;   //in m/s  --> cnnot slide below this speed (sliding limit at 0%)
    private const float MAXIMUM_SLIDING_LIMIT = 30.0f;  //30m/s == 108km/h  --> speed above which the sliding limit will not grow any more
    private const float SLIDING_MAXIMUM_SLIDER_RATIO = 0.7f;    //percentage of the slider triggering a slide when reaching MAXIMUM_SLIDING_LIMIT
    private const float MAXIMUM_SLIDING_TIME = 0.3f;

    private float timeOfSliding;
    
    private float carPower;                
    private float steeringPower;      
    private float wheelsGrip;

    private bool isSliding;

    public SliderControl sliderControl;
    public GameObject skidMarks;
    private Rigidbody2D rb;

    private bool canMove;     

    public float getSpeed()
    {
        return rb.velocity.magnitude;  // = forwardVelocityMagnitude
    }

    // Start is called before the first frame update
    void Start()
    {
        rb = GetComponent<Rigidbody2D>();
        rb.collisionDetectionMode = CollisionDetectionMode2D.Continuous;
        rb.mass = CAR_MASS;
        rb.drag = LINEAR_DRAG;
        rb.angularDrag = ANGULAR_DRAG;

        rb.centerOfMass = new Vector2(0.0f, 0.0f);  //center of mass in front of the car so the back wheels have more couple force when a collision occurs

        carPower = NORMAL_CAR_POWER;
        steeringPower = NORMAL_STEERING_POWER;           
        wheelsGrip = NORMAL_WHEEL_GRIP;

        SetCanMove(false);
        isSliding = false;
        timeOfSliding = MAXIMUM_SLIDING_TIME;
        SetSkidMarks(false);
    }

    private void FixedUpdate()
    {
        timeOfSliding += Time.deltaTime;

        if (canMove)
        {
            //trigger a slide (> and not >= so its not sliding when limit is at 0)
            if (GetSlidingLimit() > sliderControl.getSlidingValue())
            {
                isSliding = true;
                timeOfSliding = 0f;
            }
            if(rb.velocity.magnitude < MINIMUM_SLIDING_SPEED || timeOfSliding > MAXIMUM_SLIDING_TIME)  //never slides bellow this limit
            {
                isSliding = false;
            }

            if (isSliding)
            {
                SetSkidMarks(true);
                steeringPower = SLIDING_STEERING_POWER;
                wheelsGrip = SLIDING_WHEEL_GRIP;                  //make the car uncontrolable
                rb.AddForce(-rb.velocity * GROUND_GRIPPINESS);    //slows the car when its sliding
            }
            else
            {
                SetSkidMarks(false);
                steeringPower = NORMAL_STEERING_POWER;
                wheelsGrip = NORMAL_WHEEL_GRIP;
                rb.AddForce(transform.up * sliderControl.getAccelValue() * carPower);   //power generated by the car power
            }

            Turn();
        }

    }

    //returns the percentage of the slider distance from the edge to the middle that will trigger a drift
    //ex : 1 means that 100% of slider will trigger a drift and 0% that it will never drift
    public float GetSlidingLimit()
    {
        float range = MAXIMUM_SLIDING_LIMIT - MINIMUM_SLIDING_SPEED;
        float actual = rb.velocity.magnitude - MINIMUM_SLIDING_SPEED;
        float percentage = actual / range;
        percentage = Mathf.Clamp(percentage, 0.0f, 1.0f);
        return percentage * SLIDING_MAXIMUM_SLIDER_RATIO;
    }

    private bool IsGoingForward()
    {
        return Vector2.Dot(rb.velocity, transform.up) > 0.0f;
    }

    //easier to implement it that way than having to calculate how the grounds impacts the car with all the forces and Torque
    private void Turn()
    {

        //do not allow the car to go backwards too fast
        if (!isSliding && !IsGoingForward() && rb.velocity.magnitude > BACKWARD_MAX_SPEED){
            rb.velocity = rb.velocity.normalized * BACKWARD_MAX_SPEED;
        }

        float forwardVelocityMagnitude = Vector2.Dot(rb.velocity, transform.up);

        //Mathf.Sqrt(forwardVelocityMagnitude) to not be able to turn when car is too slow
        if (IsGoingForward()){
            transform.Rotate(0, 0, sliderControl.getTurnValue() * steeringPower * Mathf.Sqrt(Mathf.Abs(forwardVelocityMagnitude)) * Time.deltaTime);
        }else{
            // (* BACKWARD_STEARING_RATIO) --> turn differently backward and (* -1) --> to keep same turning movement
            transform.Rotate(0, 0, sliderControl.getTurnValue() * steeringPower * -BACKWARD_STEARING_RATIO * Mathf.Sqrt(Mathf.Abs(forwardVelocityMagnitude)) * Time.deltaTime);
        }

        //Ground reaction on the wheels
        Vector2 forwardVelocity = transform.up * forwardVelocityMagnitude;
        Vector2 edgeVelocity = transform.right * Vector2.Dot(rb.velocity, transform.right);
        rb.velocity = forwardVelocity + edgeVelocity * wheelsGrip;
    }

    private void SetSkidMarks(bool visibility)
    {
        foreach (TrailRenderer skidMark in skidMarks.GetComponentsInChildren<TrailRenderer>())
        {
            skidMark.emitting = visibility;
        }
    }

    public void SetCanMove(bool move)
    {
        canMove = move;
    }
}
